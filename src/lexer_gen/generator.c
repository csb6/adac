/*
lexer_gen - lexer generator
Copyright (C) 2025  Cole Blakley

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
*/
#include "generator.h"
#include <assert.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "ast.h"
#include "error.h"
#include "string_view.h"

#define CHAR_COUNT 256u

typedef struct {
    uint8_t* data;
    uint8_t col_count;
} Grid;

static uint8_t s_col_count;

static void generate_type(const TypeDecl* type, FILE* output);
static void generate_class_table(const uint8_t class_table[static CHAR_COUNT], const StringView* table_name, FILE* output);
static void generate_state_table(const uint8_t class_table[static CHAR_COUNT], uint8_t class_count, const TableDecl* table, FILE* output);
static uint8_t build_class_table(const TableDecl* table, uint8_t class_table[static 256]);
static int compare_char_row(const void* a, const void* b);
static uint8_t find_state(const TableDecl* table_decl, const StringView* name);
static void init_grid(Grid* grid, uint8_t col_count);
static uint8_t* cell_at(Grid* grid, uint32_t row, uint32_t col);
static char* format_path(const char* base_dir_path, const char* filename);

void generate(const Module* module, const char* output_dir_path)
{
    char* token_h_path = format_path(output_dir_path, "token.h");
    FILE* token_h = fopen(token_h_path, "w");
    if(!token_h) {
        perror(token_h_path);
        error_exit();
    }
    free(token_h_path);
    fprintf(token_h, "/* Automatically generated by lexer_gen */\n"
                     "#ifndef LEXER_GEN_TOKEN_H\n"
                     "#define LEXER_GEN_TOKEN_H\n"
                     "#include <stdint.h>\n\n");
    for(const TypeDecl* type = module->types; type != NULL; type = type->next) {
        generate_type(type, token_h);
    }
    fprintf(token_h, "#endif /*LEXER_GEN_TOKEN_H*/\n");
    fclose(token_h);

    char* lexer_table_path = format_path(output_dir_path, "lexer_table.c");
    FILE* lexer_table_file = fopen(lexer_table_path, "w");
    if(!lexer_table_file) {
        perror(lexer_table_path);
        error_exit();
    }
    free(lexer_table_path);
    fprintf(lexer_table_file, "/* Automatically generated by lexer_gen */\n"
                              "#include \"token.h\"\n\n");
    for(const TableDecl* table = module->tables; table != NULL; table = table->next) {
        uint8_t class_table[CHAR_COUNT] = {0};
        uint8_t class_count = build_class_table(table, class_table);
        fprintf(stderr, "Size of '%.*s': %u\n", SV(table->name), class_count * table->istate_count);

        generate_class_table(class_table, &table->name, lexer_table_file);
        generate_state_table(class_table, class_count, table, lexer_table_file);
    }
    fclose(lexer_table_file);
}

static
void generate_type(const TypeDecl* type, FILE* output)
{
    switch(type->kind) {
        case TYPE_OPTION:
            fprintf(output, "typedef uint8_t %.*s;\n"
                            "enum {\n", SV(type->name));
            for(uint8_t i = 0; i < type->u.option.option_count; ++i) {
                fprintf(output, "  %.*s,\n", SV(type->u.option.options[i]));
            }
            fprintf(output, "  %.*s_COUNT\n"
                            "};\n\n", SV(type->name));
            break;
        case TYPE_RANGE:
            // Range types are not printed. They are just used as dimensions in tables
            break;
        default:
            assert(false);
    }
}

static
void generate_class_table(const uint8_t class_table[static CHAR_COUNT], const StringView* table_name, FILE* output)
{
    fprintf(output, "static const uint8_t %.*s_classes[256] = {\n", SV(*table_name));
    for(uint16_t i = 0; i < CHAR_COUNT; ++i) {
        // Don't list characters in class 0 (the default class). They will be
        // default initialized to 0
        if(class_table[i]) {
            fprintf(output, "  [%u] = %u,\n", i, class_table[i]);
        }
    }
    fprintf(output, "};\n");
}

static
void generate_state_table(const uint8_t class_table[static CHAR_COUNT], uint8_t class_count, const TableDecl* table, FILE* output)
{
    fprintf(output, "static const uint8_t %.*s[%u][%u] = {\n", SV(table->name), table->istate_count, class_count);
    // Worst case: every character belongs to its own class, so size row buffer accordingly
    uint8_t state_row[CHAR_COUNT];
    for(const IState* istate = table->istates; istate != NULL; istate = istate->next) {
        uint8_t default_transition = istate->default_transition->next_state; 
        memset(state_row, default_transition, class_count);
        for(uint16_t i = 0; i < istate->transition_count; ++i) {
            const Transition* transition = istate->transitions + i;
            switch(transition->kind) {
                case TRANSITION_CHAR:
                    state_row[class_table[(uint8_t)transition->u.c]] = transition->next_state;
                    break;
                case TRANSITION_RANGE:
                    for(char c = transition->u.range.start; c <= transition->u.range.end; ++c) {
                        uint8_t class = class_table[(uint8_t)c];
                        assert(state_row[class] == default_transition
                            || state_row[class] == transition->next_state);
                        state_row[class] = transition->next_state;
                    }
                    break;
                case TRANSITION_OTHERS:
                    // Already handled above
                    break;
                default:
                    assert(false && "Unknown transition type");
            }
        }
        fprintf(output, " /* %.*s */ {", SV(istate->name));
        for(uint16_t i = 0; i < class_count; ++i) {
            fprintf(output, " %u,", state_row[i]);
        }
        fprintf(output, " },\n");
    }
    fprintf(output, "};\n");
}

static
uint8_t build_class_table(const TableDecl* table, uint8_t class_table[static CHAR_COUNT])
{
    Grid char_transitions = {0};
    init_grid(&char_transitions, table->istate_count + 1); // +1 to reserve a column for the character key
    uint8_t istate_num = 0;
    for(const IState* istate = table->istates; istate != NULL; istate = istate->next) {
        // First, set entire column to the default value (i.e. the next_state of the 'others' transition)
        assert(istate->default_transition);
        uint8_t default_next_state = find_state(table, &istate->default_transition->next_state_name);
        istate->default_transition->next_state = default_next_state;
        for(uint16_t j = 0; j < CHAR_COUNT; ++j) {
            *cell_at(&char_transitions, j, istate_num) = default_next_state;
        }
        // Write the cells for the rest of the transitions
        for(uint8_t i = 0; i < istate->transition_count; ++i) {
            Transition* transition = istate->transitions + i;
            switch(transition->kind) {
                case TRANSITION_CHAR:
                    transition->next_state = find_state(table, &transition->next_state_name);
                    *cell_at(&char_transitions, transition->u.c, istate_num) = transition->next_state;
                    break;
                case TRANSITION_RANGE: {
                    uint8_t next_state = find_state(table, &transition->next_state_name);
                    transition->next_state = next_state;
                    for(char c = transition->u.range.start; c <= transition->u.range.end; ++c) {
                        *cell_at(&char_transitions, c, istate_num) = next_state;
                    }
                    break;
                }
                case TRANSITION_OTHERS:
                    // Already handled above
                    break;
                default:
                    assert(false);
            }
        }
        ++istate_num;
    }
    // Group rows with identical transitions together
    s_col_count = char_transitions.col_count;
    qsort(char_transitions.data, CHAR_COUNT, char_transitions.col_count * sizeof(*char_transitions.data), compare_char_row);

    // Write out the class for each character
    uint8_t class_count = 0;
    class_table[*cell_at(&char_transitions, 0, char_transitions.col_count - 1)] = class_count;
    for(uint16_t i = 1; i < CHAR_COUNT; ++i) {
        if(compare_char_row(cell_at(&char_transitions, i, 0), cell_at(&char_transitions, i - 1, 0)) != 0) {
            ++class_count;
        }
        class_table[*cell_at(&char_transitions, i, char_transitions.col_count - 1)] = class_count;
    }
    ++class_count;
    free(char_transitions.data);

    // Find the class with the most members and make them class 0 so we can skip them in designated
    // initializers (since they will default to 0). This reduces the size of the generated source code
    uint8_t class_counts[256] = {0};
    for(uint16_t i = 0; i < CHAR_COUNT; ++i) {
        ++class_counts[class_table[i]];
    }
    uint8_t largest_class = 0;
    for(uint8_t i = 0; i < class_count; ++i) {
        if(class_counts[i] > class_counts[largest_class]) {
            largest_class = i;
        }
    }
    // Swap largest_class's class number with class 0
    for(uint16_t i = 0; i < CHAR_COUNT; ++i) {
        if(class_table[i] == largest_class) {
            class_table[i] = 0;
        } else if(class_table[i] == 0) {
            class_table[i] = largest_class;
        }
    }
    return class_count;
}

static
int compare_char_row(const void* a, const void* b)
{
    // Compare rows lexicographically
    return memcmp(a, b, s_col_count - 1); // -1 to ignore final column (i.e. the key for that row)
}

static
uint8_t find_state(const TableDecl* table_decl, const StringView* name)
{
    uint16_t idx = 0;
    // First, see if this is an intermediate state
    for(const IState* istate = table_decl->istates; istate != NULL; istate = istate->next) {
        if(string_view_eq(&istate->name, name)) {
            return idx;
        }
        ++idx;
    }
    assert(idx == table_decl->istate_count);
    // If not, then must be a token (i.e. a final state)
    OptionType* domain;
    uint8_t end;
    if(table_decl->domain->kind == TYPE_OPTION) {
        domain = &table_decl->domain->u.option;
        end = domain->option_count - 1;
    } else {
        assert(table_decl->domain->kind == TYPE_RANGE);
        assert(table_decl->domain->u.range.base_type->kind == TYPE_OPTION);
        // TODO: adjust for offset if subtype range type doesn't start at 0
        assert(table_decl->domain->u.range.start == 0);
        domain = &table_decl->domain->u.range.base_type->u.option;
        end = table_decl->domain->u.range.end;
    }
    for(uint16_t i = 0; i <= end; ++i) {
        if(string_view_eq(domain->options + i, name)) {
            // Tokens are offset by istate_count to distinguish them from
            // istates
            return idx + i;
        }
    }
    assert(false);
    return idx;
}

static
void init_grid(Grid* grid, uint8_t col_count)
{
    grid->col_count = col_count;
    grid->data = calloc(CHAR_COUNT * (uint32_t)col_count, sizeof(uint8_t));
    // Last column contains the character key for each row
    for(uint16_t c = 0; c < CHAR_COUNT; ++c) {
        *cell_at(grid, c, col_count - 1) = c;
    }
}

static
uint8_t* cell_at(Grid* grid, uint32_t row, uint32_t col)
{
    assert(row < CHAR_COUNT);
    assert(col < grid->col_count);
    return grid->data + (row * grid->col_count + col);
}

static
char* format_path(const char* base_dir_path, const char* filename)
{
    int buffer_len = snprintf(NULL, 0, "%s/%s", base_dir_path, filename) + 1;
    char* path_buffer = calloc(buffer_len, sizeof(char));
    snprintf(path_buffer, buffer_len, "%s/%s", base_dir_path, filename);
    return path_buffer;
}
