-- CD2A87A.TST

-- OBJECTIVE:
--     CHECK THAT IF A SIZE SPECIFICATION CAN BE GIVEN FOR A DERIVED,
--     UNCONSTRAINED ACCESS-TYPE, THEN A SIZE SPECIFICATION CAN ALSO BE
--     GIVEN FOR A DERIVED ACCESS-TYPE WHOSE PARENT HAS A NONSTATIC
--     INDEX OR DISCRIMINANT CONSTRAINT.

-- APPLICABILITY CRITERIA:
--     THIS TEST IS APPLICABLE ONLY TO IMPLEMENTATIONS THAT SUPPORT
--     SIZE SPECIFICATIONS FOR DERIVED, UNCONSTRAINED ACCESS-TYPES.

--     IF SIZE SPECIFICATIONS FOR DERIVED, UNCONSTRAINED ACCESS-TYPES
--     ARE NOT SUPPORTED, THEN THE SIZE SPECIFICATION FOR 'CHECK_TYPE'
--     MUST BE REJECTED.

-- MACRO SUBSTITUTION:
--     THE MACRO ACC_SIZE IS THE SIZE, IN BITS, OF A DERIVED
--     ACCESS-TYPE.
--     THIS MACRO IS SUBSTITUTED INTO THE CONSTANT DECLARATION GIVEN
--     BELOW.

-- HISTORY:
--     VCL  09/15/87 CREATED ORIGINAL TEST.

WITH REPORT; USE REPORT;
PROCEDURE CD2A87A IS
     SPECIFIED_SIZE : CONSTANT := $ACC_SIZE;

     SUBTYPE INDX IS INTEGER RANGE 0 .. 15;

     TYPE T1 IS ARRAY (INDX RANGE <>) OF CHARACTER;

     TYPE AT1 IS ACCESS T1;

     TYPE CHECK_TYPE IS NEW AT1;
     FOR CHECK_TYPE'SIZE USE SPECIFIED_SIZE;      -- N/A => ERROR.
BEGIN
     TEST ("CD2A87A", "IF A SIZE SPECIFICATION CAN BE GIVEN FOR A " &
                      "DERIVED, UNCONSTRAINED ACCESS-TYPE, THEN A " &
                      "SIZE SPECIFICATION CAN ALSO BE GIVEN FOR A " &
                      "DERIVED ACCESS-TYPE WHOSE PARENT HAS A " &
                      "NONSTATIC INDEX OR DISCRIMINANT CONSTRAINT");

     DECLARE
          SUBTYPE INDX IS INTEGER RANGE 0 .. 15;

          FUNCTION IDENT (P : INDX) RETURN INDX IS
          BEGIN
               IF EQUAL (3, 3) THEN
                    RETURN P;
               ELSE
                    RETURN 0;
               END IF;
          END IDENT;
     BEGIN

          DECLARE
               N : CONSTANT INDX := IDENT (2);

               TYPE T1 IS ARRAY (INDX RANGE <>) OF CHARACTER;

               TYPE PARENT_1 IS ACCESS T1 (1 .. N);

               TYPE TEST_INDEX IS NEW PARENT_1;
               FOR TEST_INDEX'SIZE USE SPECIFIED_SIZE;

               ACCESS_INDEX : TEST_INDEX;

               TYPE T2 (D : INDX) IS
                    RECORD
                         CASE D IS
                              WHEN 0 =>
                                   NULL;
                              WHEN 1 =>
                                   C1_I : INTEGER;
                              WHEN 2 =>
                                   C2_S : STRING (1 .. 10);
                              WHEN OTHERS =>
                                   NULL;
                         END CASE;
                    END RECORD;

               TYPE PARENT_2 IS ACCESS T2 (N);

               TYPE TEST_DISCR IS NEW PARENT_2;
               FOR TEST_DISCR'SIZE USE SPECIFIED_SIZE;

               ACCESS_DISCR : TEST_DISCR;
          BEGIN
               IF TEST_INDEX'SIZE > SPECIFIED_SIZE THEN
                    FAILED ("TEST_INDEX'SIZE IS TOO LARGE");
               END IF;

               IF ACCESS_INDEX'SIZE > TEST_INDEX'SIZE THEN
                    FAILED ("ACCESS_INDEX'SIZE IS TOO LARGE");
               END IF;

               IF TEST_DISCR'SIZE > SPECIFIED_SIZE THEN
                    FAILED ("TEST_DISCR'SIZE IS TOO LARGE");
               END IF;

               IF ACCESS_DISCR'SIZE > TEST_DISCR'SIZE THEN
                    FAILED ("ACCESS_DISCR'SIZE IS TOO LARGE");
               END IF;
          END;
     END;

     RESULT;
END CD2A87A;
