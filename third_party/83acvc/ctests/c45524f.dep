-- C45524F.DEP

-- OBJECTIVE:
--     CHECK THAT UNDERFLOW DOES NOT RAISE AN EXCEPTION.
--     CHECK WHETHER UNDERFLOW IS GRADUAL (BECAUSE RESULTS WITH MINIMUM
--     EXPONENT CAN BE UNNORMALIZED) OR IMMEDIATE (BECAUSE RESULTS ARE
--     NORMALIZED).
--     THIS TEST IS TO BE REPEATED FOR 'DIGITS = 5 .. 30.

-- APPLICABILITY CRITERIA:
--     THIS TEST IS APPLICABLE TO IMPLEMENTATIONS WHICH SUPPORT A
--     VALUE OF DIGITS GREATER THAN OR EQUAL TO 10.

--     IF 'DIGITS 10' IS NOT SUPPORTED, THEN THE DECLARATION OF 'TYPE F'
--     MUST BE REJECTED.

-- HISTORY:
--     JBG 02/24/84 CREATED ORIGINAL TEST.
--     TBN 10/31/85 RENAMED FROM C45526A-B.ADA.
--     JRK 04/01/86 REVISED TO CHECK FOR GRADUAL UNDERFLOW.  HIGHER
--                  PRECISION TESTS GENERATED FROM BASIC TEST.
--     DHH 01/11/88 ADDED APPLICABILITY CRITERIA AND STANDARD HEADER.
--     RJW 07/13/88 ADDED TYPE 'LOOP_RANGE'.

WITH REPORT; USE REPORT;
PROCEDURE C45524F IS

     TYPE F IS DIGITS 10;                            -- N/A => ERROR.

     TYPE LOOP_RANGE IS RANGE F'MACHINE_EMIN .. 0;

     VAL           : F := 0.0;
     RADIX_INVERSE : F := 0.0;

BEGIN
     TEST ("C45524F", "CHECK THAT UNDERFLOW DOES NOT RAISE " &
                      "AN EXCEPTION");

     COMMENT ("F'DIGITS = " & INTEGER'IMAGE (F'DIGITS));
     COMMENT ("F'MACHINE_RADIX = " & INTEGER'IMAGE (F'MACHINE_RADIX));
     COMMENT ("F'MACHINE_MANTISSA = " &
              INTEGER'IMAGE (F'MACHINE_MANTISSA));
     COMMENT ("F'MACHINE_EMIN = " & INTEGER'IMAGE (F'MACHINE_EMIN));

     IF EQUAL (3,3) THEN
          VAL := 1.0;
          RADIX_INVERSE := 1.0 / F(F'MACHINE_RADIX);
     END IF;

     BEGIN
          -- TRY TO COMPUTE SMALLEST POSITIVE NORMALIZED MACHINE
          -- REPRESENTABLE NUMBER FOR BASE TYPE OF F, NAMELY:
          -- F'MACHINE_RADIX ** (F'MACHINE_EMIN - 1).

          FOR I IN LOOP_RANGE LOOP
               VAL := VAL * RADIX_INVERSE;
          END LOOP;

          IF VAL < 0.0 THEN
               FAILED ("NONNEGATIVE * POSITIVE = NEGATIVE, (1)");
          ELSIF VAL = 0.0 THEN
               FAILED ("UNDERFLOW OCCURED WHILE COMPUTING SMALLEST " &
                       "POSITIVE NORMALIZED MACHINE REPRESENTABLE " &
                       "NUMBER FOR BASE TYPE OF F");
          ELSE COMMENT ("HAVE COMPUTED SMALLEST POSITIVE NORMALIZED " &
                        "MACHINE REPRESENTABLE NUMBER FOR BASE TYPE " &
                        "OF F");

               VAL := VAL * RADIX_INVERSE;

               IF VAL < 0.0 THEN
                    FAILED ("NONNEGATIVE * POSITIVE = NEGATIVE, (2)");
               ELSIF VAL = 0.0 THEN
                    COMMENT ("UNDERFLOW IS NOT GRADUAL (NORMALIZED " &
                             "RESULTS)");
               ELSE COMMENT ("UNDERFLOW IS GRADUAL (UNNORMALIZED " &
                             "RESULTS)");

                    -- TRY TO COMPUTE SMALLEST POSITIVE UNNORMALIZED
                    -- MACHINE REPRESENTABLE NUMBER FOR BASE TYPE OF F,
                    -- NAMELY:
                    -- F'MACHINE_RADIX ** (F'MACHINE_EMIN -
                    --                     F'MACHINE_MANTISSA).

                    FOR I IN 3 .. F'MACHINE_MANTISSA LOOP
                         VAL := VAL * RADIX_INVERSE;
                    END LOOP;

                    IF VAL < 0.0 THEN
                         FAILED ("NONNEGATIVE * POSITIVE = NEGATIVE, " &
                                 "(3)");
                    ELSIF VAL = 0.0 THEN
                         COMMENT ("UNDERFLOW OCCURED WHILE COMPUTING " &
                                  "SMALLEST POSITIVE UNNORMALIZED " &
                                  "MACHINE REPRESENTABLE NUMBER FOR " &
                                  "BASE TYPE OF F");
                    ELSE COMMENT ("HAVE COMPUTED SMALLEST POSITIVE " &
                                  "UNNORMALIZED MACHINE " &
                                  "REPRESENTABLE NUMBER FOR BASE " &
                                  "TYPE OF F");

                         VAL := VAL * 2#0.01#;    -- USE 1/4 INSTEAD OF
                                                  -- 1/2 TO PREVENT
                                                  -- UPWARD ROUNDING OF
                                                  -- RESULT.

                         IF VAL < 0.0 THEN
                              FAILED ("NONNEGATIVE * POSITIVE = " &
                                      "NEGATIVE, (4)");
                         ELSIF VAL = 0.0 THEN
                              COMMENT ("UNDERFLOW OCCURED AS " &
                                       "EXPECTED");
                         ELSE COMMENT ("*** UNDERFLOW SHOULD HAVE " &
                                       "OCCURRED BY NOW, BUT HAS NOT");

                              -- TRY TO ELIMINATE GUARD BITS.

                              DECLARE
                                   N : F;
                              BEGIN
                                   IF F'MACHINE_RADIX = 2 THEN
                                        N := 2#0.01#;  -- TO PREVENT
                                                       -- UPWARD
                                                       -- ROUNDING.
                                   ELSE N := RADIX_INVERSE;
                                   END IF;

                                   -- ASSUMING AT MOST 3 GUARD DIGITS
                                   -- (OF RADIX F'MACHINE_RADIX).

                                   FOR I IN 1 .. 3 LOOP
                                        VAL := VAL * N;
                                   END LOOP;

                                   IF VAL < 0.0 THEN
                                        FAILED ("NONNEGATIVE * " &
                                                "POSITIVE = " &
                                                "NEGATIVE, (5)");
                                   ELSIF VAL = 0.0 THEN
                                        COMMENT ("UNDERFLOW HAS " &
                                                 "FINALLY OCCURED");
                                   ELSE FAILED ("UNABLE TO CAUSE " &
                                                "UNDERFLOW, EVEN " &
                                                "AFTER ALLOWING FOR " &
                                                "MINIMUM EXPONENT, " &
                                                "UNNORMALIZED " &
                                                "MANTISSA, AND GUARD " &
                                                "BITS");
                                   END IF;
                              END;
                         END IF;
                    END IF;
               END IF;
          END IF;

     EXCEPTION
          WHEN NUMERIC_ERROR =>
               FAILED ("NUMERIC_ERROR RAISED FOR UNDERFLOW");
          WHEN CONSTRAINT_ERROR =>
               FAILED ("CONSTRAINT_ERROR RAISED FOR UNDERFLOW");
          WHEN OTHERS =>
               FAILED ("OTHER EXCEPTION RAISED FOR UNDERFLOW");
     END;

     RESULT;
END C45524F;
