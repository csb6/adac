-- C46012B.DEP

-- OBJECTIVE:
--     CHECK THAT FLOATING POINT VALUES ARE CORRECTLY CONVERTED
--     TO INTEGER TYPES AND DETERMINE THE METHOD USED FOR ROUNDING.

--         A) CONVERSION OF INTEGRAL FLOATING-POINT VALUES
--            TO PRE-DEFINED TYPE 'INTEGER'.
--         B) ROUNDING FLOATING-POINT VALUES TO PRE-DEFINED
--            TYPE 'INTEGER'.
--         C) DETERMINING METHOD USED TO ROUND TO PRE-DEFINED
--            TYPE 'INTEGER'.
--         D) CONVERSION OF INTEGRAL FLOATING-POINT VALUES
--            TO USER-DEFINED LONGEST INTEGER TYPE.
--         E) ROUNDING FLOATING-POINT VALUES TO USER-DEFINED
--            LONGEST INTEGER TYPE.
--         F) DETERMINING METHOD USED TO ROUND TO USER-DEFINED
--            LONGEST INTEGER TYPE.
--     THIS TEST IS REPEATED FOR DIGITS = 5 .. 30.

-- APPLICABILITY CRITERIA:
--     THIS TEST IS APPLICABLE ONLY TO IMPLEMENTATIONS WHICH SUPPORT
--     A VALUE OF DIGITS GREATER THAN OR EQUAL TO 6.

--     IF 'DIGITS 6' IS NOT SUPPORTED, THEN THE DECLARATION OF
--     'TYPE FT' MUST BE REJECTED.

-- HISTORY:
--     JRK 06/03/86 CREATED ORIGINAL TEST.
--     DHH 01/14/88 ADDED APPLICABILITY CRITERIA AND STANDARD HEADER.

WITH SYSTEM; USE SYSTEM;
WITH REPORT; USE REPORT;

PROCEDURE C46012B IS

     TYPE FT IS DIGITS 6;                            -- N/A => ERROR.

     TYPE LONGEST_INTEGER IS RANGE MIN_INT .. MAX_INT;

     FT_0  : FT := 1.0;
     FT_1  : FT := 0.0;
     FT_N1 : FT := 0.0;

     FT_ROUND_1 : FT := 0.0;
     FT_ROUND_2 : FT := 0.0;

     C15  : FT := 0.0;
     C25  : FT := 0.0;
     CN15 : FT := 0.0;
     CN25 : FT := 0.0;

BEGIN

     TEST ("C46012B", "CONVERSION OF FLOATING POINT TO INTEGER TYPES");

     IF EQUAL (3, 3) THEN
          FT_0  := 0.0;
          FT_1  := 1.0;
          FT_N1 := -1.0;

          FT_ROUND_1 := 1.5 - FT'EPSILON;
          FT_ROUND_2 := 1.5 + FT'EPSILON;

          C15  := 1.5;
          C25  := 2.5;
          CN15 := -1.5;
          CN25 := -2.5;
     END IF;

     COMMENT ("FT'MANTISSA =" & INTEGER'IMAGE(FT'MANTISSA));

     -- (A) CONVERT INTEGRAL-VALUED FT TO INTEGER.

     DECLARE

          LARGE_FT      : FT      := 0.0;
          LARGE_INTEGER : INTEGER := 0;

     BEGIN

          -- DETERMINE LARGEST MODEL FT WITH INTEGRAL VALUE <=
          -- INTEGER'LAST.

          DECLARE
               I : INTEGER := 0;
          BEGIN
               -- WANT 2 ** FT'MANTISSA - 1, IF NOT TOO LARGE.
               -- AVOID CONVERSIONS AND OVERFLOW.

               WHILE I < FT'MANTISSA AND
                     LARGE_INTEGER <= (INTEGER'LAST - 1) / 2
               LOOP
                    LARGE_FT := 2.0 * LARGE_FT + 1.0;
                    LARGE_INTEGER := 2 * LARGE_INTEGER + 1;
                    I := I + 1;
               END LOOP;

               IF I < FT'MANTISSA THEN
                    -- USE INTEGER'LAST INSTEAD.
                    DECLARE
                         E : FT := 1.0;
                         X : INTEGER := INTEGER'LAST - LARGE_INTEGER;
                    BEGIN
                         WHILE X > 0 LOOP
                              IF X MOD 2 > 0 THEN
                                   LARGE_FT := LARGE_FT + E;
                              END IF;
                              E := 2.0 * E;
                              X := X / 2;
                         END LOOP;
                    END;
                    LARGE_INTEGER := INTEGER'LAST;
               END IF;
          END;

          -- CONVERT INTEGRAL-VALUED FT TO INTEGER.

          IF INTEGER (FT_0) /= 0 OR
             INTEGER (FT_1) /= 1 OR
             INTEGER (FT_N1) /= -1 THEN
               FAILED ("INCORRECT CONVERSION OF 0.0, 1.0, OR -1.0 TO " &
                       "INTEGER");
          END IF;

          IF INTEGER (LARGE_FT) /= LARGE_INTEGER OR
             INTEGER (-LARGE_FT) /= - ABS LARGE_INTEGER THEN
               FAILED ("INCORRECT CONVERSION OF LARGE FT TO INTEGER");
          END IF;

     END;

     -- (B) ROUND FT TO INTEGER.

     IF INTEGER (FT_ROUND_1) /= 1 OR
        INTEGER (FT_ROUND_2) /= 2 OR
        INTEGER (-FT_ROUND_1) /= IDENT_INT (-1) OR
        INTEGER (-FT_ROUND_2) /= IDENT_INT (-2) THEN
          FAILED ("INCORRECT ROUNDING OF FT TO INTEGER");
     END IF;

     -- (C) DETERMINE METHOD USED TO ROUND TO INTEGER.

     DECLARE

          C15R  : INTEGER := INTEGER (C15);
          C25R  : INTEGER := INTEGER (C25);
          CN15R : INTEGER := INTEGER (CN15);
          CN25R : INTEGER := INTEGER (CN25);

          C15_1   : BOOLEAN := C15R = 1;
          C15_2   : BOOLEAN := C15R = 2;
          C25_2   : BOOLEAN := C25R = 2;
          C25_3   : BOOLEAN := C25R = 3;

          CN15_N1 : BOOLEAN := CN15R = -1;
          CN15_N2 : BOOLEAN := CN15R = -2;
          CN25_N2 : BOOLEAN := CN25R = -2;
          CN25_N3 : BOOLEAN := CN25R = -3;

          TYPE ACC_STRING IS ACCESS STRING;
          MODE : ACC_STRING;

     BEGIN

          COMMENT ("1.5 IS ROUNDED TO INTEGER" & INTEGER'IMAGE(C15R));
          COMMENT ("2.5 IS ROUNDED TO INTEGER" & INTEGER'IMAGE(C25R));
          COMMENT ("-1.5 IS ROUNDED TO INTEGER " &
                   INTEGER'IMAGE(CN15R));
          COMMENT ("-2.5 IS ROUNDED TO INTEGER " &
                   INTEGER'IMAGE(CN25R));

          IF C15_2 AND C25_3 AND CN15_N1 AND CN25_N2 THEN
               MODE := NEW STRING'("ROUND TO +INFINITY");
          ELSIF C15_1 AND C25_2 AND CN15_N2 AND CN25_N3 THEN
               MODE := NEW STRING'("ROUND TO -INFINITY");
          ELSIF C15_1 AND C25_2 AND CN15_N1 AND CN25_N2 THEN
               MODE := NEW STRING'("ROUND TO ZERO");
          ELSIF C15_2 AND C25_3 AND CN15_N2 AND CN25_N3 THEN
               MODE := NEW STRING'("ROUND AWAY FROM ZERO");
          ELSIF C15_2 AND C25_2 THEN
               MODE := NEW STRING'("ROUND POSITIVE TO EVEN - CHECK " &
                                   "ABOVE RESULTS FOR NEGATIVE VALUES");
               IF CN15_N2 AND CN25_N2 THEN
                    MODE := NEW STRING'("ROUND TO EVEN");
               END IF;
          ELSIF C15_1 AND C25_3 THEN
               MODE := NEW STRING'("ROUND POSITIVE TO ODD - CHECK " &
                                   "ABOVE RESULTS FOR NEGATIVE VALUES");
               IF CN15_N1 AND CN25_N3 THEN
                    MODE := NEW STRING'("ROUND TO ODD");
               END IF;
          ELSE
               MODE := NEW STRING'("UNKNOWN");
          END IF;

          COMMENT ("THE ROUNDING APPROACH USED FOR TYPE INTEGER IS " &
                   "APPARENTLY: " & MODE.ALL);

          IF NOT (C15_1 OR C15_2) OR NOT (C25_2 OR C25_3) THEN
               FAILED ("INCORRECT ROUNDING OF POSITIVE VALUES TO " &
                       "INTEGER");
          END IF;

          IF NOT (CN15_N1 OR CN15_N2) OR NOT (CN25_N2 OR CN25_N3) THEN
               FAILED ("INCORRECT ROUNDING OF NEGATIVE VALUES TO " &
                       "INTEGER");
          END IF;

     END;

     -- (D) CONVERT INTEGRAL-VALUED FT TO LONGEST_INTEGER.

     DECLARE

          LARGE_FT              : FT              := 0.0;
          LARGE_LONGEST_INTEGER : LONGEST_INTEGER := 0;

     BEGIN

          -- DETERMINE LARGEST MODEL FT WITH INTEGRAL VALUE <=
          -- LONGEST_INTEGER'LAST.

          DECLARE
               I : INTEGER := 0;
          BEGIN
               -- WANT 2 ** FT'MANTISSA - 1, IF NOT TOO LARGE.
               -- AVOID CONVERSIONS AND OVERFLOW.

               WHILE I < FT'MANTISSA AND
                     LARGE_LONGEST_INTEGER <=
                     (LONGEST_INTEGER'LAST - 1) / 2
               LOOP
                    LARGE_FT := 2.0 * LARGE_FT + 1.0;
                    LARGE_LONGEST_INTEGER :=
                              2 * LARGE_LONGEST_INTEGER + 1;
                    I := I + 1;
               END LOOP;

               IF I < FT'MANTISSA THEN
                    -- USE LONGEST_INTEGER'LAST INSTEAD.
                    DECLARE
                         E : FT := 1.0;
                         X : LONGEST_INTEGER := LONGEST_INTEGER'LAST -
                                                LARGE_LONGEST_INTEGER;
                    BEGIN
                         WHILE X > 0 LOOP
                              IF X MOD 2 > 0 THEN
                                   LARGE_FT := LARGE_FT + E;
                              END IF;
                              E := 2.0 * E;
                              X := X / 2;
                         END LOOP;
                    END;
                    LARGE_LONGEST_INTEGER := LONGEST_INTEGER'LAST;
               END IF;
          END;

          -- CONVERT INTEGRAL-VALUED FT TO LONGEST_INTEGER.

          IF LONGEST_INTEGER (FT_0) /= 0 OR
             LONGEST_INTEGER (FT_1) /= 1 OR
             LONGEST_INTEGER (FT_N1) /= -1 THEN
               FAILED ("INCORRECT CONVERSION OF 0.0, 1.0, OR -1.0 TO " &
                       "LONGEST_INTEGER");
          END IF;

          IF LONGEST_INTEGER (LARGE_FT) /= LARGE_LONGEST_INTEGER OR
             LONGEST_INTEGER (-LARGE_FT) /= - ABS LARGE_LONGEST_INTEGER
          THEN
               FAILED ("INCORRECT CONVERSION OF LARGE FT TO " &
                       "LONGEST_INTEGER");
          END IF;

     END;

     -- (E) ROUND FT TO LONGEST_INTEGER.

     IF LONGEST_INTEGER (FT_ROUND_1) /= 1 OR
        LONGEST_INTEGER (FT_ROUND_2) /= 2 OR
        LONGEST_INTEGER (-FT_ROUND_1) /=
               LONGEST_INTEGER (IDENT_INT (-1)) OR
        LONGEST_INTEGER (-FT_ROUND_2) /=
               LONGEST_INTEGER (IDENT_INT (-2)) THEN
          FAILED ("INCORRECT ROUNDING OF FT TO LONGEST_INTEGER");
     END IF;

     -- (F) DETERMINE METHOD USED TO ROUND TO LONGEST_INTEGER.

     DECLARE

          C15R  : LONGEST_INTEGER := LONGEST_INTEGER (C15);
          C25R  : LONGEST_INTEGER := LONGEST_INTEGER (C25);
          CN15R : LONGEST_INTEGER := LONGEST_INTEGER (CN15);
          CN25R : LONGEST_INTEGER := LONGEST_INTEGER (CN25);

          C15_1   : BOOLEAN := C15R = 1;
          C15_2   : BOOLEAN := C15R = 2;
          C25_2   : BOOLEAN := C25R = 2;
          C25_3   : BOOLEAN := C25R = 3;

          CN15_N1 : BOOLEAN := CN15R = -1;
          CN15_N2 : BOOLEAN := CN15R = -2;
          CN25_N2 : BOOLEAN := CN25R = -2;
          CN25_N3 : BOOLEAN := CN25R = -3;

          TYPE ACC_STRING IS ACCESS STRING;
          MODE : ACC_STRING;

     BEGIN

          COMMENT ("1.5 IS ROUNDED TO LONGEST_INTEGER" &
                   LONGEST_INTEGER'IMAGE(C15R));
          COMMENT ("2.5 IS ROUNDED TO LONGEST_INTEGER" &
                   LONGEST_INTEGER'IMAGE(C25R));
          COMMENT ("-1.5 IS ROUNDED TO LONGEST_INTEGER " &
                   LONGEST_INTEGER'IMAGE(CN15R));
          COMMENT ("-2.5 IS ROUNDED TO LONGEST_INTEGER " &
                   LONGEST_INTEGER'IMAGE(CN25R));

          IF C15_2 AND C25_3 AND CN15_N1 AND CN25_N2 THEN
               MODE := NEW STRING'("ROUND TO +INFINITY");
          ELSIF C15_1 AND C25_2 AND CN15_N2 AND CN25_N3 THEN
               MODE := NEW STRING'("ROUND TO -INFINITY");
          ELSIF C15_1 AND C25_2 AND CN15_N1 AND CN25_N2 THEN
               MODE := NEW STRING'("ROUND TO ZERO");
          ELSIF C15_2 AND C25_3 AND CN15_N2 AND CN25_N3 THEN
               MODE := NEW STRING'("ROUND AWAY FROM ZERO");
          ELSIF C15_2 AND C25_2 THEN
               MODE := NEW STRING'("ROUND POSITIVE TO EVEN - CHECK " &
                                   "ABOVE RESULTS FOR NEGATIVE VALUES");
               IF CN15_N2 AND CN25_N2 THEN
                    MODE := NEW STRING'("ROUND TO EVEN");
               END IF;
          ELSIF C15_1 AND C25_3 THEN
               MODE := NEW STRING'("ROUND POSITIVE TO ODD - CHECK " &
                                   "ABOVE RESULTS FOR NEGATIVE VALUES");
               IF CN15_N1 AND CN25_N3 THEN
                    MODE := NEW STRING'("ROUND TO ODD");
               END IF;
          ELSE
               MODE := NEW STRING'("UNKNOWN");
          END IF;

          COMMENT ("THE ROUNDING APPROACH USED FOR TYPE " &
                   "LONGEST_INTEGER IS APPARENTLY: " & MODE.ALL);

          IF NOT (C15_1 OR C15_2) OR NOT (C25_2 OR C25_3) THEN
               FAILED ("INCORRECT ROUNDING OF POSITIVE VALUES TO " &
                       "LONGEST_INTEGER");
          END IF;

          IF NOT (CN15_N1 OR CN15_N2) OR NOT (CN25_N2 OR CN25_N3) THEN
               FAILED ("INCORRECT ROUNDING OF NEGATIVE VALUES TO " &
                       "LONGEST_INTEGER");
          END IF;

     END;

     RESULT;

END C46012B;
