*-----------------------------------------------------------------------------
*-                                                                          --
*-                                 G N A T                                  --
*-                                                                          --
*-                            COMPILER UTILITIES                            --
*-                                                                          --
*-                               X E I N F O                                --
*-                                                                          --
*-                            $Revision: 1.17 $                             --
*-                                                                          --
*-             Copyright (c) 1992,1993, NYU, All Rights Reserved            --
*-                                                                          --
*- GNAT is free software;  you can  redistribute it  and/or modify it under --
*- terms  of the GNU  General  Public  License  as  published  by the  Free --
*- Software  Foundation;  either version 2,  or (at your option)  any later --
*- version.  GNAT is distributed  in the hope  that it will be useful,  but --
*- but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANT- --
*- ABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public --
*- License  for  more details.  You should have received  a copy of the GNU --
*- General Public License along with GNAT;  see file COPYING. If not, write --
*- to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA. --
*-                                                                          --
*-----------------------------------------------------------------------------

* Program to construct C header file a-einfo.h (C version of einfo.ads spec,
* for use by Gigi, contains all definitions and access functions, but does not
* contain set procedures, since Gigi is not allowed to modify the GNAT tree)
*
*   Input files:
*
*      einfo.ads     spec of Einfo package
*      einfo.adb     body of Einfo package
*
*   Output files:
*
*      a-einfo.h     Corresponding c header file
*
* Note: this program assumes that einfo.ads has been compiled without errors
*
* An optional argument allows the specification of an output file name to
* override the default a-einfo.h file name for the generated output file.
*
* Most, but not all of the functions in Einfo can be inlined in the C header.
* Those functions which cannot be inlined are identified in the header and
* in terminal output when this utility program is run.

        "$Revision: 1.17 $" "$Rev" "ision: " break(' ') $ xeinforev

        arg = trim(host(1))
        arg = ident(arg, "0") trim(host(0))
        ofile = ident(arg) 'a-einfo.h'
        ofile = differ(arg) arg

        lineno = 0
        &stlimit = -1
        input(.in,1,'einfo.ads')
        input(.inb,5,'einfo.adb')
        output(.out,2,ofile)
        &anchor = 1
        wsp = span(' ' char(9)) | ''

* Get einfo revs and write header to output file

slp1    line = inb
        ident(line)   :s(err)
        line breakx('$') '$Rev' 'ision: ' break(' ') $ einfobrev
.                                                     :f(slp1)

slp     line = in
        ident(line)    :s(start)
        line breakx('$') '$Rev' 'ision: ' break(' ') $ einforev :s(vsn)
        line '--                                 S p e c       ' =
.            '--                              C Header File    '

        line '--' = '/*'
        line rtab(2) $ a '--' = a '*/'
        out = line                :(slp)

vsn     out = '/*                 Generated by xeinfo revision ' xeinforev
.             ' using                  */'
        out = '/*                         einfo.ads revision ' einforev
.             '                         */'
        out = '/*                         einfo.adb revision ' einfobrev
.             '                         */'           :(slp)

start   lc = 'abcdefghijklmnopqrstuvwxyz'
        uc = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
        out =

* status<N> = 'D' for defined function, 'I' for inlined function

        status = table(200)

*  Get non-comment line (comment lines skipped)

        define('getlins()a,b')                  :(fd2)

getlins getlins = trim(in)                      :f(freturn)
        lineno = lineno + 1
        ident(getlins)                          :s(getlins)
        getlins wsp $ a '--' =                  :f(return)s(getlins)

*  Process function header into C form and output it

fd2     define('sethead(line,term)a,args,formal,formaltype,filler,i') :(fd3)

sethead line wsp $ a
.       'procedure'                             :s(return)

        line wsp $ a
.       'function' wsp break(' ') $ Name =      :s(sh5)f(err)

sh5     args =
        line wsp $ filler '(' =                 :f(sh8)
        args = filler '('

sh6     line break(' :') $ formal wsp ':' wsp
.            breakx(' );') $ formaltype =       :f(err)
        args = args formaltype ' ' formal
        line wsp '; ' =                         :f(sh7)
        args = args ','                         :(sh6)

sh7     line wsp ')' =
        args = args ')'

sh8     line wsp 'return' wsp breakx(' ;') $ rtn :s(sh10)
*       return statement may be on next line.
        line = trim(in)
        line wsp 'return' wsp breakx(' ;') $ rtn :f(err)

sh10    i =
        i = ident(status<Name>,'I') "INLINE "
        out = a i rtn ' ' Name args term
.                                               :(return)

fd3

* find pragma inlines

i0      lineno = 0

i1      line = getlins()                        :f(n0)
        line wsp 'pragma Inline (' break(')') $ name  :f(i1)
        status<name> = 'I'                      :(i1)

* process specification

n0      input(.in,4,'einfo.ads')
        lineno = 0

n1      line = getlins()
        line wsp 'package '                     :s(n2)f(n1)

n2      V = 0
        line = getlins()
        line wsp 'type Entity_Kind'             :f(n2a)

n3      line = getlins()
        line wsp break(',') $ N ','             :f(n4)
        out = '   #define ' rpad(N,32) ' ' V
        V = V + 1                               :(n3)

n4      line wsp rem $ N | break(')') $ N       :f(err)
        out = '   #define ' rpad(N,32) ' ' V

n5      line = getlins()                        :f(err)
        line wsp 'function'                     :s(n9)
        line wsp $ a 'subtype ' break(' ') $ N  :f(n5)

n8      getlins() wsp break(' ') $ N1           :f(err)

n8a     line = trim(in)                         :f(err)
        lineno = lineno + 1
        line wsp '-- ' rem $ N2                 :s(n8a)

        line wsp break(';') $ N3                :f(err)
        out = a 'SUBTYPE (' N ', Entity_Kind, '
        out = a '   ' N1 ', ' N3 ')'            :(n5)

n9      line wsp $ aa 'function' wsp break(' (') $ FN
        status<FN> = ident(status<FN>) 'D'
        out = ident(status<FN>,'D') '   #define ' FN
.                        ' einfo__' replace(FN,uc,lc)
        sethead(line,';')
        line = getlins()
        line wsp 'function First_Private'       :f(n9)
        sethead(line,';')

* Read body to find inlined functions

        out =
        out = '   /********************************/'
        out = '   /* Bodies for Inlined Functions */'
        out = '   /********************************/'

        input(.in,3,'einfo.adb')
        lineno = 1

n10     line = getlins()                        :f(n13)
        line wsp $ aa 'function' wsp break(' (') $ FN :f(n10)
        ident(status<FN>,'I')                   :s(n10a)

        terminal = ident(status<FN>,'D')
.               "Need body for " FN             :(n10)

n10a    line breakx('r') 'return'               :s(n10b)
        nline = getlins()
        nline wsp =
        line = line nline                       :(n10a)

n10b    fline = line
n10c    line = getlins()
        line wsp "begin"                        :f(n10c)

        line = getlins()
        line wsp "pragma " ("Assert (" | "Debug (")
.                                               :f(n10d)

* pragma Assert found, get its continuation lines

alpp    line breakx(';')                        :s(alpt)
        line = getlins()                        :(alpp)
alpt    line = getlins()

n10d    line wsp "if Debug"                     :f(n11)
        line = getlins()

n11     line breakx('-') $ a '--' = a
        line wsp 'return ' break(';') $ expr    :f(n11a)
        line = getlins()
        line wsp 'end' breakx(';') ';'          :f(err)
        expr breakx(' ') $ a " in " rem $ b = "IN (" a ', ' b ")"
        expr breakx(' ') $ a " = " rem $ b = a ' == ' b
        out =
        sethead(fline,'')

* special kludge for Get_Name_Entity_Id case

        expr = ident(expr, 'Entity_Id (Get_Name_Table_Info (Id))')
.                          '(Entity_Id) Get_Name_Table_Info (Id)'

        out = aa '   { return ' expr '; }'      :(n10)

* Multi-line function, assume no translation required

n11a    out =
        sethead(fline,' {')
n11b    pline = line
        line = getlins()                        :f(err)
        line wsp $ xx  "end;"                   :s(n11c)
        line breakx('-') $ a '--' = a
        out = pline                             :(n11b)

n11c    out = pline
        out = xx    ' }'                        :(n10)

n13     out =
        out =
.         '/* End of einfo.h (C version of Einfo package specification)'
.               ' */'    :(end)

end
